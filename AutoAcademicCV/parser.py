# encoding: utf-8

from .textfile import openFile
from .latexencode import utf8tolatex
import sys
import re
from operator import attrgetter

class Parser:
    """ Class to automatic format elements in an academic CV, such as
    patents, papers, projects, etc.
    """

    def __init__(self, mode="plain", token_list=[], colors=False):
        """
        " Constructor:
        " input_file : a valid file with tokens and value follwing the specified format
        " mode : can be "plain" or "tex". It indicates the kind of replacement for 
        "        special symbols and accents, "plain" avoid any change
        " colors : if true, it uses the terminal as a color terminal for warnings and
        "          errors mainly
        " token_list : a non-empty list with the tokens, if an empty list is given, a default
        "              basic list for papers is generated by this software
        """
        self._mode = mode
        self.works = []
        self.reg = {} # rules of regular expressions
        self.regPrior = [] # priority of the rules

        if colors:
            self._err = '\033[91mError\033[0m'
            self._warn = '\033[93mWarning\033[0m'
        else:
            self._err = "Error"
            self._warn = "Warning"

        if len(token_list) == 0:
            self._token_list = [
                'idtex', 'authors', 'title', 'journal', 'conference', 'book', 'proc', 'pp1', 'pp2',
                'month', 'year', 'volume', 'number', 'doi', 'city', 'country'
            ]
        else:
            self._token_list = token_list

    def sort(self, fields, reverse=False):
        """
        " Sort the works according to a field.
        "
        " fields : is the list of fields.
        " reverse : if this field is True, the list is reversed.
        """
        self._sortFields = fields
        self.works = sorted(self.works, key=self._sortFunc, reverse=reverse)

    def regularExpr(self, input_file):
        """
        " Parse a a text with rules following regular expressions.
        " The format is as follows:
        "
        " -- comment a line
        " token :: "regular_expression" :: "replacement"
        " token :: "regular_expression"
        "
        """

        finput = openFile(input_file)
        line = 0
        current_work = {}
        for tline in finput:
            line += 1
            # remove white spaces, both sides of the string
            tline = tline.strip()

            # ignore comments and blank lines
            if ( len(tline) == 0 or
                 (len(tline) >= 2 and tline[0] == '-' and tline[1] == '-') ):
                continue # ignore comments starting by --

            try:
                token, expr, repl = tline.split("::")
            except:
                try:
                    token, expr = tline.split("::")
                    repl = '""'
                except:
                    print (self._msg("the regular expression is empty.",
                                     line=line,ttype="error", indent=4, filename=input_file))
                    sys.exit(1)

            token = token.strip()
            repl = repl.strip()
            expr = expr.strip()
            if expr[0] != expr[-1] or len(expr) < 2 or expr[0] != '"':
                print (self._msg('the regular expression must be encapsulated between quotemarks "',
                                 line=line, ttype="error", indent=4, filename=input_file))
                sys.exit(1)
            if repl[0] != repl[-1] or len(repl) < 2 or repl[0] != '"':
                print (self._msg('the replacement must be encapsulated between quotemarks "',
                                 line=line, ttype="error", indent=4, filename=input_file))
                sys.exit(1)
            # remove quotemarks:
            expr = expr[1:-1]
            repl = repl[1:-1]
            self.regPrior.append(token)
            self.reg[token] = [expr, repl]
            print("    New rule added: " + token + " := [" + expr + "] --> [" + repl + "]")
        print("")
        return


    def template(self, template_text, header_text="", footer_text=""):
        """
        " Apply a template to the given works:
        "
        " template_text : a text with variables, a variable is preceded by $, so if token "authors"
        "                 exists in token_list, the variable is named $authors, and it will be
        "                 replaced by the list of elements detected in the file
        " header_text : a header inserted at the beginning of the document
        " footer_text : a footer added after document
        """
        if len(self.works) == 0:
            print (self._msg("the list of works is empty. Doing nothing.",
                             ttype="warning", indent=4))
            return str(header_text) + "" + str(footer_text)
        if template_text == "":
            print (self._msg("the template is empty. Doing nothing.",
                             ttype="warning", indent=4))
            return str(header_text) + "" + str(footer_text)
        text = ""
        for work in self.works:
            ctemplate = template_text
            prev_template = ctemplate
            change = True
            iteration = 0
            while change:
                iteration += 1
                # replace the template until no more changes can be done
                for field in work:
                    if work[field] is not None:
                        ctemplate = ctemplate.replace("$" + field, work[field])
                        # ctemplate has the previous
                # apply replacing rules
                print("   Rules iteration: " + str(iteration))
                for token in self.regPrior:
                    expr, rep = self.reg[token]
                    prev = len(ctemplate)
                    ctemplate = re.sub(r"" + expr, rep, ctemplate)
                    char_changed = len(ctemplate) - prev
                    if char_changed == 0:
                        print (self._msg("Rule [" + token + "] didn't change anything!",
                                         ttype="warning", indent=4))
                    else:
                        print("    Rule [" + token +
                              "] applied, " + str(char_changed)  + " characters changed.")
                # check if some change is produced
                change = ctemplate != prev_template
                prev_template = ctemplate
            text += ctemplate

        # Remove unused tokens:
        for field in self._token_list:
            text = text.replace("$" + field, "")
        return str(header_text) + text + str(footer_text)


    def parse(self, input_file, filterby=None):
        """
        " Parse a text file:
        " input_file : a valid file with tokens and value follwing the specified format
        "
        " FORMAT of input_file:
        " -- is a comment
        " ( opens a new publication, project, or whatever...
        " ) closes a current publication, project or whatever...
        " token : blah blah blah -- indicates a token to be replaced by blah blah blah
        """
        token_list = self._token_list

        finput = openFile(input_file)
        stage = ")"
        line = 0
        current_work = {}
        for tline in finput:
            line += 1
            # remove white spaces, both sides of the string
            tline = tline.strip()

            # ignore comments and blank lines
            if ( len(tline) == 0 or
                 (len(tline) >= 2 and tline[0] == '-' and tline[1] == '-') ):
                continue # ignore comments starting by --

            fields = tline.split(":", 1) # only the first time

            if len(fields) < 2:
                if fields[0] == '(':
                    if stage == '(':
                        print (self._msg("missing ')'. Last work was not properly closed.",
                                         line=(line-1), ttype="error", indent=4,
                                         filename=input_file))
                        sys.exit(1)
                    else: # new work ****
                        stage = '('
                        current_work = {}
                elif fields[0] == ')':
                    if stage == ')':
                        print (self._msg("missing '('. This work was not properly open.",
                                         line=(line-1), ttype="error", indent=4,
                                         filename=input_file))
                        sys.exit(1)
                    else: # append paper to list ***
                        stage = ')'
                        if filterby is None:
                            self.works.append(current_work)
                        else: # a filter is applied
                            variable = re.findall(r"\$\b\w+\b", filterby)
                            if len(variable) > 0:
                                variable = variable[0]
                            if len(variable) > 0:
                                filterby = re.sub(r"\$" + variable[1:],
                                                  "current_work['" + variable[1:] + "']",
                                                  filterby)
                            try:
                                if eval(filterby):
                                    self.works.append(current_work)
                            except:
                                print (self._msg(" current work " + str(current_work) +
                                                 " filtered by filter '" + filterby + "'.",
                                                 filename=input_file,
                                                 line=line, ttype="warning", indent=4))
                else:   # ignore strange lines
                    print (self._msg("strange field '" + str(fields) +
                                     "'. This work was not properly open.",
                                     line=line, filename=input_file, ttype="warning", indent=4))
                    continue
            elif self._parse_field(fields, line, token_list,
                                   input_file):
                if stage == ')':
                    print (self._msg("missing '('. This work was not properly open.",
                                     line=line, ttype="error", indent=4,
                                     filename=input_file))
                    sys.exit(1)
                # Add field to current work:
                text = fields[1].strip()
                # Apply modes if any:
                if self._mode == "tex":
                    text = utf8tolatex(text)
                current_work[fields[0].strip()] = text


        if stage == '(':
            print (self._msg("missing ')'. Last work was not properly closed.",
                             line=(line-1), ttype="error", indent=4,
                             filename=input_file))
            sys.exit(1)
        finput.close()


    def _parse_field(self, fields, line, token_list, filename):
        """ Parse a field and its value, line is used for errors """
        if fields[0] not in token_list:
            print (self._msg("unknown token '" + fields[0] + "'. Recogniced tokens are:",
                             indent=3, ttype="warning"))
            print (self._msg(str(sorted(token_list)), indent=5, filename=filename))
            return False
        else:
            return True


    def _msg(self, msg, indent=0, ttype="other", line=None, filename=None):
        """
        " Display a message of error or warning:
        " text : is the text of the message
        " ttype : is the type of the message, "error", "warning", "other"
        " line : if None, line is ignored, otherwise is added to the message
        """
        text = ""
        for i in range(indent):
            text += " "
        if ttype == "error":
            text += self._err
        elif ttype == "warning":
            text += self._warn
        if line is not None:
            text += " in line " + str(line)
        if filename is not None:
            text += " at file " + filename
        if ttype != "other":
            text += ": "
        text += msg
        return text


    def _sortFunc(self, dictobj):
        """
        "
        """
        text = ""

        for f in self._sortFields:
            try:
                data = dictobj[f]
                if type(f) == int:
                    text += "%020d " % data
                else:
                    text += " " + str(data)
            except:
                print (self._msg("argument '" + f + "' doesn't exist in " +
                                 str(dictobj) + " when sorting!",
                                 ttype="warning", indent=4))

        return text

